package com.qiyi.plugin.collector

import com.android.build.gradle.api.ApkVariant
import com.android.build.gradle.tasks.ProcessAndroidResources
import com.android.builder.dependency.level2.AndroidDependency
import com.android.builder.model.AndroidLibrary
import com.android.builder.model.MavenCoordinates
import com.google.common.collect.ArrayListMultimap
import com.google.common.collect.ListMultimap
import com.google.common.collect.Lists
import com.qiyi.plugin.QYPluginExtension
import com.qiyi.plugin.collector.dependence.AarDependenceInfo
import com.qiyi.plugin.collector.dependence.DependenceInfo
import com.qiyi.plugin.collector.res.ResourceEntry
import com.qiyi.plugin.collector.res.StyleableEntry
import org.gradle.api.GradleException
import org.gradle.api.Project
import org.gradle.util.VersionNumber

/**
 * Collect all(host+plugin) resources&styleables in the APK and reassign the resource ID
 *
 * @author zhengtao
 */
class ResourceCollector {

    private Project project
    private QYPluginExtension pluginExt
    private ApkVariant apkVariant
    /**
     * Gradle task of process resource in Android build system
     */
    private ProcessAndroidResources processResTask
    /**
     * R symbol File that records all resources, generated by aapt
     */
    private File allRSymbolFile
    /**
     * Host R symbol File, need saved after the host APK compilation
     */
    private File hostRSymbolFile

    /**
     * Map of all resources, KEY is the resource type, e.g. drawable, VALUE is all entries of this type
     */
    ListMultimap<String, ResourceEntry> allResources = ArrayListMultimap.create()
    /**
     * List of all styleables
     */
    List<StyleableEntry> allStyleables = Lists.newArrayList()


    private ListMultimap<String, ResourceEntry> hostResources = ArrayListMultimap.create()
    private List<StyleableEntry> hostStyleables = Lists.newArrayList()

    /**
     * pluginResources = allResources - hostResources
     */
    ListMultimap<String, ResourceEntry> pluginResources = ArrayListMultimap.create()
    List<StyleableEntry> pluginStyleables = Lists.newArrayList()

    //group:artifact:version
    Set<String> hostDependencies = [] as Set<String>

    Set<AarDependenceInfo> retainedAarLibs = [] as Set<AarDependenceInfo>
    Set<DependenceInfo> stripDependencies = [] as Collection<DependenceInfo>

    public ResourceCollector(Project project, ProcessAndroidResources par, ApkVariant variant) {

        this.project = project
        this.pluginExt = project.extensions.findByType(QYPluginExtension)

        this.apkVariant = variant
        processResTask = par

        boolean isAbove3 = pluginExt.agpVersion >= VersionNumber.parse("3.0")
        allRSymbolFile = isAbove3 ? par.textSymbolOutputFile : new File(par.textSymbolOutputDir, 'R.txt')
        hostRSymbolFile = pluginExt.hostSymbolFile
    }

    /**
     * Perform resource collection and ID redistribution
     */
    def collect() {
        //1. First, resolve dependencies info from prepareDependenciesTask
        prepareDependencies()

        //2、Second, collect all resources by parsing the R symbol file.
        parseResEntries(allRSymbolFile, allResources, allStyleables)

        //3、Then, collect host resources by parsing the host apk R symbol file, should be stripped.
        parseResEntries(hostRSymbolFile, hostResources, hostStyleables)
        stripDependencies.each {
            if (it instanceof AarDependenceInfo) {
                parseResEntries(it.aarRSymbolFile, hostResources, hostStyleables)
            }
        }

        //4、Compute the resources that should be retained in the plugin apk.
        filterPluginResources()

        //5、Reassign the resource ID. If the resource entry exists in host apk, the reassign ID
        //   should be same with value in host apk; If the resource entry is owned by plugin project,
        //   then we should recalculate the ID value.
        reassignPluginResourceId()

        //6、Collect all the resources in the retained AARs, to regenerate the R java file that uses the new resource ID
        retainedAarLibs.each {
            gatherReservedAarResources(it)
        }
    }

    /**
     * Collect project dependencies from host or plugin self
     */
    private void prepareDependencies() {

        if (pluginExt.hostDependencies != null) {
            pluginExt.hostDependencies.split(";").each { dep ->
                def module = dep.split(':')
                hostDependencies.add("${module[0]}:${module[1]}")
            }
        }

        if (pluginExt.agpVersion >= VersionNumber.parse("2.3")) {
            // 2.3.3
            prepareAndroidDependency()
        } else {
            // 2.2.0
            prepareAndroidLibrary()
        }
    }

    /**
     * 处理Android Gradle Plugin 3.0.0+的依赖关系
     * 或者2.2.x版本的依赖关系
     */
    private void prepareAndroidLibrary() {
        println "prepareAndroidLibrary() ..............."

        Set<AndroidLibrary> androidLibraries
        if (pluginExt.agpVersion >= VersionNumber.parse("3.0")) {
            // AGP 3.0.0, gather the dependencies with AndroidLibrary
            throw new GradleException("Not support for agp version ${pluginExt.agpVersion}")
//            DependencyCollector dependencyCollector = new DependencyCollector(project, apkVariant)
//            androidLibraries = dependencyCollector.androidLibraries
        } else {
            androidLibraries = processResTask.libraries
        }

        androidLibraries.each {
            println "${it.folder}, ${it.symbolFile}, ${it.jarFile}, ${it.bundle}"

            def mavenCoordinates = it.resolvedCoordinates
            if (hostDependencies.contains("${mavenCoordinates.groupId}:${mavenCoordinates.artifactId}")) {
                println "strip Aar: ${mavenCoordinates.groupId}:${mavenCoordinates.artifactId}:${mavenCoordinates.version}"
                AarDependenceInfo aarDependenceInfo = new AarDependenceInfo(
                        mavenCoordinates.groupId,
                        mavenCoordinates.artifactId,
                        mavenCoordinates.version,
                        it)
                aarDependenceInfo = aarDependenceInfo.fixAarManifest(project, apkVariant)
                aarDependenceInfo = aarDependenceInfo.fixRSymbol(project, apkVariant)
                stripDependencies.add(aarDependenceInfo)
            } else {
                println "retained Aar: ${mavenCoordinates.groupId}:${mavenCoordinates.artifactId}:${mavenCoordinates.version}"
                AarDependenceInfo aarDependenceInfo = new AarDependenceInfo(
                        mavenCoordinates.groupId,
                        mavenCoordinates.artifactId,
                        mavenCoordinates.version,
                        it)
                aarDependenceInfo = aarDependenceInfo.fixAarManifest(project, apkVariant)
                aarDependenceInfo = aarDependenceInfo.fixRSymbol(project, apkVariant)
                retainedAarLibs.add(aarDependenceInfo)
            }
        }
    }

    /**
     * 处理Android Gradle Plugin 2.3.3+, 3.0.0+的依赖关系
     */
    private void prepareAndroidDependency() {
        println "prepareAndroidDependency() ..............."

        Set<AndroidDependency> androidDependencies
        if (pluginExt.agpVersion >= VersionNumber.parse("3.0")) {
            // AGP 3.0.0, manually gather the dependencies
            DependencyCollector dependencyCollector = new DependencyCollector(project, apkVariant)
            androidDependencies = dependencyCollector.androidDependencies
        } else {
            androidDependencies = processResTask.androidDependencies
        }

        androidDependencies.each {
            println "${it.extractedFolder}, ${it.symbolFile}, ${it.jarFile}"

            def mavenCoordinates = it.coordinates as MavenCoordinates
            if (hostDependencies.contains("${mavenCoordinates.groupId}:${mavenCoordinates.artifactId}")) {
                println "strip Aar: ${mavenCoordinates.groupId}:${mavenCoordinates.artifactId}:${mavenCoordinates.version}"
                AarDependenceInfo aarDependenceInfo = new AarDependenceInfo(
                        mavenCoordinates.groupId,
                        mavenCoordinates.artifactId,
                        mavenCoordinates.version,
                        it)
                aarDependenceInfo = aarDependenceInfo.fixAarManifest(project, apkVariant)
                aarDependenceInfo = aarDependenceInfo.fixRSymbol(project, apkVariant)
                stripDependencies.add(aarDependenceInfo)
            } else {
                println "retained Aar: ${mavenCoordinates.groupId}:${mavenCoordinates.artifactId}:${mavenCoordinates.version}"
                AarDependenceInfo aarDependenceInfo = new AarDependenceInfo(
                        mavenCoordinates.groupId,
                        mavenCoordinates.artifactId,
                        mavenCoordinates.version,
                        it)
                aarDependenceInfo = aarDependenceInfo.fixAarManifest(project, apkVariant)
                aarDependenceInfo = aarDependenceInfo.fixRSymbol(project, apkVariant)
                retainedAarLibs.add(aarDependenceInfo)
            }
        }
    }

    /**
     * Collect resources and styleables by parsing R symbol file
     * @param RSymbolFile R symbol file records the resource entries
     * @param resourcesMap Map used to store resources
     * @param styleableList List used to store styleables
     */
    private static void parseResEntries(File RSymbolFile, ListMultimap resourcesMap, List styleableList) {
        if (RSymbolFile == null || !RSymbolFile.exists()) {
            return
        }

        println "parseResEntries for file: ${RSymbolFile.absolutePath}"
        RSymbolFile.eachLine { line ->
            /**
             *  Line Content:
             *  Common Res:  int string abc_action_bar_home_description 0x7f090000
             *  Styleable:   int[] styleable TagLayout { 0x010100af, 0x7f0102b5, 0x7f0102b6 }
             *            or int styleable TagLayout_android_gravity 0
             */
            if (!line.empty) {
                def tokenizer = new StringTokenizer(line)
                def valueType = tokenizer.nextToken()     // value type (int or int[])
                def resType = tokenizer.nextToken()      // resource type (attr/string/color etc.)
                def resName = tokenizer.nextToken()
                def resId = tokenizer.nextToken('\n').trim()

                if (resType == 'styleable') {
                    styleableList.add(new StyleableEntry(resName, resId, valueType))
                } else {
                    resourcesMap.put(resType, new ResourceEntry(resType, resName, Integer.decode(resId)))
                }
            }
        }
    }

    /**
     * Filter out the resources that need to be retained in the plugin apk,
     * pluginResources = allResources - hostResources
     */
    private void filterPluginResources() {
        allResources.values().each {
            def index = hostResources.get(it.resourceType).indexOf(it)
            if(index >= 0){
                /**
                 * If the resource entry exists in host apk, assign the host resource ID of this entry
                 * as the new resource id.
                 * Then replace the object reference in host resource collection with the object
                 * in all resource collection, to make both of them point to the same object
                 */
                it.newResourceId = hostResources.get(it.resourceType).get(index).resourceId
                hostResources.get(it.resourceType).set(index, it)
            } else {
                pluginResources.put(it.resourceType, it)
            }
        }

        allStyleables.each {
            def index = hostStyleables.indexOf(it)
            if(index >= 0) {
                /**
                 * Do not support the same name but different content styleable entry
                 */
                it.value = hostStyleables.get(index).value
                hostStyleables.set(index, it)
            } else {
                pluginStyleables.add(it)
            }
        }
    }

    /**
     * Reassign the ID for resources need retained in the plugin apk
     * Set the packageId specified in the build.gradle file, and reassign type&entry ID
     */
    private void reassignPluginResourceId() {

        def resourceIdList = []
        pluginResources.keySet().each { String resType ->
            List<ResourceEntry> entryList = pluginResources.get(resType)
            resourceIdList.add([resType: resType, typeId: entryList.empty ? -100 : parseTypeIdFromResId(entryList.first().resourceId)])
        }


        resourceIdList.sort { t1, t2 ->
            t1.typeId - t2.typeId
        }

        int lastType = 1
        resourceIdList.each {
            if (it.typeId < 0) {
                return
            }
            def typeId = 0
            def entryId = 0
            typeId = lastType++
            // 对 attr 排个序，liveshow 的编译环境，id 顺序不是按照 name 排序的，导致 R.styleable.xxx 数组内容错乱，读取 attribute 时可能丢失
            pluginResources.get(it.resType).sort(new Comparator<ResourceEntry>() {
                @Override
                int compare(ResourceEntry r0, ResourceEntry r1) {
                    return r0.resourceId - r1.resourceId
                }
            })
            pluginResources.get(it.resType).each {
                it.setNewResourceId(pluginExt.packageId, typeId, entryId++)
            }
        }

        List<ResourceEntry> attrEntries = allResources.get('attr')

        pluginStyleables.findAll { it.valueType == 'int[]'}.each { StyleableEntry styleableEntry->
            List<String> values = styleableEntry.valueAsList
            values.eachWithIndex { hexResId, idx ->
                ResourceEntry resEntry = attrEntries.find { it.hexResourceId == hexResId }
                if (resEntry != null) {
                    values[idx] = resEntry.hexNewResourceId
                }
            }
            styleableEntry.value = values
        }
    }

    /**
     * Parse the type part of a android resource id
     */
    def parseTypeIdFromResId(int resourceId) {
        resourceId >> 16 & 0xFF
    }


    /**
     * Collect all resources the aar project can access
     * @param aarDependenceInfo aar dependence info
     */
    def gatherReservedAarResources(AarDependenceInfo aarDependenceInfo) {
        def aarResKeys = aarDependenceInfo.resourceKeys
        if (aarResKeys.empty) return

        allResources.keySet().each { resType ->
            allResources.get(resType).each { resEntry ->
                if (aarResKeys.contains("${resType}:${resEntry.resourceName}")) {
                    aarDependenceInfo.aarResources.put(resType, resEntry)
                }
            }
        }

        aarDependenceInfo.aarStyleables = allStyleables.findAll { styleableEntry ->
            aarResKeys.contains("styleable:${styleableEntry.name}")
        }
    }

    /**
     * Returns the mapping from the original ID to the redistributed ID
     */
    def getResIdMap() {
        def idMap = [:] as Map<Integer, Integer>
        allResources.values().each { resEntry ->
            idMap.put(resEntry.resourceId, resEntry.newResourceId)
        }
        return idMap
    }


    public void dump() {
        final def resSplitDir = new File(project.buildDir, 'generated')

        println "dump *********Retained Resources*********"
        final def retainTypeFile = new File(resSplitDir, 'retainType.txt')
        if (!retainTypeFile.exists()) {
            retainTypeFile.createNewFile()
        }
        retainTypeFile.withPrintWriter { pw ->
            pw.println "************ Resources in Plugin ***********"
            pluginResources.values().each {
                pw.println "${it.resourceType} ${it.resourceName} 0x${Integer.toHexString(it.resourceId)} 0x${Integer.toHexString(it.newResourceId)}"
            }
            pw.println "****************Styleables*****************"
            pluginStyleables.each {
                pw.println "${it.name} ${it.valueType} ${it.value}"
            }
        }

        println "dump *********Striped Resources*********"
        final def stripTypeFile = new File(resSplitDir, "stripType.txt")
        if (!stripTypeFile.exists()) {
            stripTypeFile.createNewFile()
        }
        stripTypeFile.withPrintWriter { pw ->
            pw.println "************ Resources from Host ***********"
            hostResources.values().each {
                pw.println "${it.resourceType} ${it.resourceName} 0x${Integer.toHexString(it.resourceId)} 0x${Integer.toHexString(it.newResourceId)}"
            }
            pw.println "****************Styleables*****************"
            hostStyleables.each {
                pw.println "${it.name} ${it.valueType} ${it.value}"
            }
        }

        println "dump *********All Resources*********"
        final def allTypeFile = new File(resSplitDir, "allType.txt")
        if (!allTypeFile.exists()) {
            allTypeFile.createNewFile()
        }
        allTypeFile.withPrintWriter { pw ->
            pw.println "************ All resources ***********"
            allResources.values().each {
                pw.println "${it.resourceType} ${it.resourceName} 0x${Integer.toHexString(it.resourceId)} 0x${Integer.toHexString(it.newResourceId)}"
            }
            pw.println "****************Styleables*****************"
            allStyleables.each {
                pw.println "${it.name} ${it.valueType} ${it.value}"
            }
        }

        println "dump *********VendorType*********"
        final def vendorTypeFile = new File(resSplitDir, 'vendorType.txt')
        if (!vendorTypeFile.exists()) {
            vendorTypeFile.createNewFile()
        }
        vendorTypeFile.withPrintWriter { pw ->
            retainedAarLibs.each { aarLib ->
                pw.println "${aarLib.name}"

                aarLib.aarResources.values().each {
                    pw.println "${it.resourceType} ${it.resourceName} 0x${Integer.toHexString(it.resourceId)} 0x${Integer.toHexString(it.newResourceId)}"
                }
            }
        }
    }

}