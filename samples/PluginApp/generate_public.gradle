import java.util.regex.Matcher
import java.util.regex.Pattern


afterEvaluate {
    android.applicationVariants.all { variant ->

        println "variant name:${variant.name}"
        File publicXml = project.rootProject.file("public.xml")
        // public.xml是否存在
        if (publicXml.exists()) {
            def scope = variant.getVariantData().getScope()
            String mergeTaskName = scope.getMergeResourcesTask().name
            Task mergeResTask = tasks.getByName(mergeTaskName)
            if (mergeResTask) {
                mergeResTask.doLast {

                    File mergeResDir = new File(mergeResTask.outputDir, "values")
                    println "mergeResDir: ${mergeResDir}"
                    // 生成ids.xml
                    File idsFile = project.rootProject.file("ids.xml")
                    if (idsFile.exists()) {
                        idsFile.delete()
                    }

                    idsFile.append("<?xml version=\"1.0\" encoding=\"utf-8\"?>")
                    idsFile.append("\n")
                    idsFile.append("<resources>")
                    idsFile.append("\n")

                    File valuesFile = new File(mergeResDir, "values.xml")
                    Set<String> existIdItems = new HashSet<String>()
                    if (valuesFile.exists()) {
                        //记录在values.xml中存在的id定义
                        def valuesNodes = new XmlParser().parse(valuesFile)
                        valuesNodes.each {
                            if ("id".equalsIgnoreCase("${it.@type}")) {
                                existIdItems.add("${it.@name}")
                            }
                        }
                    }

                    def publicXMLNodes = new XmlParser().parse(publicXml)
                    Pattern drawableGeneratePattern = Pattern.compile('^(.*?_)([0-9]{0,})$')
                    publicXMLNodes.each {
                        //获取public.xml中定义的id类型item
                        if ("id".equalsIgnoreCase("${it.@type}")) {
                            //如果在values.xml中没有定义，则添加到ids.xml中
                            //如果已经在values.xml中定义，则忽略它
                            if (!existIdItems.contains("${it.@name}")) {
                                idsFile.append("\t<item type=\"id\" name=\"${it.@name}\" />\n")
                            } else {
                                project.logger.error "already exist id item ${it.@name}, ignore it"
                            }
                        } else if ("drawable".equalsIgnoreCase("${it.@type}")) {
                            //以'_数字'结尾的drawable资源，此类资源是aapt编译时生成的nested资源，如avd_hide_password_1, avd_hide_password_2
                            //但是可能会有其他资源掺杂，如abc_btn_check_to_on_mtrl_000, abc_btn_check_to_on_mtrl_015
                            //为了将此类资源过滤掉，将正则匹配到的数字转成int，对比原始数字部分匹配字符串，如果一致，则是aapt生成
                            //重要：为了避免此类nested资源生成顺序发生改变，应该禁止修改此类资源
                            Matcher matcher = drawableGeneratePattern.matcher(it.@name)
                            if (matcher.matches() && matcher.groupCount() == 2) {
                                String number = matcher.group(2)
                                if (number.equalsIgnoreCase(Integer.parseInt(number).toString())) {
                                    //project.logger.info "[${PREFIX}] declared drawable resource ${it.@name} which is generated by aapt. like use '<aapt:attr name=\"android:drawable\">'"
                                    idsFile.append("\t<item type=\"drawable\" name=\"${it.@name}\" />\n")
                                }
                            }
                        }
                    }

                    idsFile.append("</resources>")
                }
            }
        } else {
            // 生成public.xml
            android.aaptOptions.additionalParameters("-P", "${publicXml}")
        }
    }
}


task reBuildPublicXml(dependsOn: ['assembleDebug']) << {
    File publicXml = project.rootProject.file("public.xml")
    File publicNewXml = project.rootProject.file(project.hasProperty("public_name") ? project.property("public_name") : "public_n.xml")
    if (publicNewXml.exists()) {
        publicNewXml.delete()
    }
    publicNewXml.createNewFile()
    def writer = publicNewXml.newPrintWriter()

    if (publicXml.exists()) {
        publicXml.eachLine { line ->
            String tmp = line.trim()
            println "public.xml line ${line}"
            if (tmp.isEmpty()) {
                return
            }
            if (tmp.startsWith("<!--") || tmp.endsWith("-->")) {
                return
            }
            println "write to new public.xml ${line}"
            writer.write(line)
            writer.write("\n")
        }
        writer.close()
    }
}

task JarSupport(type: Jar, dependsOn: ['compileReleaseJavaWithJavac']) {
    archiveName = "android_support_${ANDROID_SUPPORT_VERSION}.jar"
    destinationDir = file('build/libs')
    from project.configurations.compile.findAll {
        def path = it.getAbsolutePath()
        (path.contains("support") || path.contains("arch")) &&
                (path.endsWith(".jar") || path.endsWith(".aar"))
    }.collect {
        if (it.getName().endsWith('.jar')) {
            project.zipTree(it)
        } else if (it.getName().endsWith('.aar')) {

            def aarDir = project.file("${project.buildDir}/aar")
            if (!aarDir.exists()) {
                aarDir.mkdirs()
            }

            def aarPath = it.getPath()
            def jarName = it.getName().replace('.aar', '.jar')
            copy {
                from zipTree(aarPath)
                into aarDir
                include('**/*.jar')
                rename 'classes.jar', jarName
            }
            project.zipTree("${aarDir.absolutePath}/$jarName")
        }
    }
    include("android/support/**/*.class")
    include("android/arch/**/*.class")
}