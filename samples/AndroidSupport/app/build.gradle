import com.android.build.gradle.api.ApkVariant

import java.util.regex.Matcher
import java.util.regex.Pattern

apply plugin: 'com.android.application'

android {
    compileSdkVersion 27
    buildToolsVersion "26.0.2"
    defaultConfig {
        applicationId "org.qiyi.support"
        minSdkVersion 14
        targetSdkVersion 26
        versionCode 1
        versionName "1.0"
        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
    }
    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
    }
}

dependencies {
    compile fileTree(dir: 'libs', include: ['*.jar'])
    // Android Support Library
    compile "com.android.support:support-v4:${ANDROID_SUPPORT_VERSION}"
    compile "com.android.support:recyclerview-v7:${ANDROID_SUPPORT_VERSION}"
    //compile "com.android.support:support-annotations:${ANDROID_SUPPORT_VERSION}"
    compile "com.android.support:appcompat-v7:${ANDROID_SUPPORT_VERSION}"
    compile "com.android.support.constraint:constraint-layout:1.1.3"
    compile "com.airbnb.android:lottie:${LOTTIE_VERSION}"

    compile "com.facebook.fresco:fresco:${FRESCO_VERSION}"
    //compile "com.airbnb.android:lottie:${LOTTIE_VERSION}"
}


afterEvaluate {

    boolean genIds = true
    android.applicationVariants.all { variant ->

        println "variant name:${variant.name}"
        if (genIds) {
            handlePublicXml(variant)
        }
    }
}

def handlePublicXml(ApkVariant variant) {
    File publicXml = project.file("public.xml")

    def scope = variant.getVariantData().getScope()
    String mergeTaskName = scope.getMergeResourcesTask().name
    Task mergeResTask = tasks.getByName(mergeTaskName)

    mergeResTask.doLast {
        copy {
            int i=0
            from(android.sourceSets.main.res.srcDirs) {
                include 'values/public.xml'
                rename 'public.xml', (i++ == 0? "public.xml": "public_${i}.xml")
            }

            into(mergeResTask.outputDir)
        }

        if (!publicXml.exists()) {
            println "publicXml file not exist"
            return
        }

        File mergeResDir = new File(mergeResTask.outputDir, "values")
        println "mergeResDir: ${mergeResDir}"
        // 生成ids.xml
        File idsFile = project.file("ids.xml")
        if (idsFile.exists()) {
            idsFile.delete()
        }

        idsFile.append("<?xml version=\"1.0\" encoding=\"utf-8\"?>")
        idsFile.append("\n")
        idsFile.append("<resources>")
        idsFile.append("\n")

        File valuesFile = new File(mergeResDir, "values.xml")
        Set<String> existIdItems = new HashSet<String>()
        if (valuesFile.exists()) {
            //记录在values.xml中存在的id定义
            def valuesNodes = new XmlParser().parse(valuesFile)
            valuesNodes.each {
                if ("id".equalsIgnoreCase("${it.@type}")) {
                    existIdItems.add("${it.@name}")
                }
            }
        }

        def publicXMLNodes = new XmlParser().parse(publicXml)
        Pattern drawableGeneratePattern = Pattern.compile('^(.*?_)([0-9]{0,})$')
        publicXMLNodes.each {
            //获取public.xml中定义的id类型item
            if ("id".equalsIgnoreCase("${it.@type}")) {
                //如果在values.xml中没有定义，则添加到ids.xml中
                //如果已经在values.xml中定义，则忽略它
                if (!existIdItems.contains("${it.@name}")) {
                    idsFile.append("\t<item type=\"id\" name=\"${it.@name}\" />\n")
                } else {
                    project.logger.error "already exist id item ${it.@name}, ignore it"
                }
            } else if ("drawable".equalsIgnoreCase("${it.@type}")) {
                //以'_数字'结尾的drawable资源，此类资源是aapt编译时生成的nested资源，如avd_hide_password_1, avd_hide_password_2
                //但是可能会有其他资源掺杂，如abc_btn_check_to_on_mtrl_000, abc_btn_check_to_on_mtrl_015
                //为了将此类资源过滤掉，将正则匹配到的数字转成int，对比原始数字部分匹配字符串，如果一致，则是aapt生成
                //重要：为了避免此类nested资源生成顺序发生改变，应该禁止修改此类资源
                Matcher matcher = drawableGeneratePattern.matcher(it.@name)
                if (matcher.matches() && matcher.groupCount() == 2) {
                    String number = matcher.group(2)
                    if (number.equalsIgnoreCase(Integer.parseInt(number).toString())) {
                        //project.logger.info "[${PREFIX}] declared drawable resource ${it.@name} which is generated by aapt. like use '<aapt:attr name=\"android:drawable\">'"
                        idsFile.append("\t<item type=\"drawable\" name=\"${it.@name}\" />\n")
                    }
                }
            }
        }

        idsFile.append("</resources>")
    }

    if (!publicXml.exists()) {
        // 生成public.xml
        android.aaptOptions.additionalParameters("-P", "${publicXml}")
    }
}


task reBuildPublicXml(dependsOn: ['assembleDebug']) << {
    File publicXml = project.file("public.xml")
    File publicNewXml = project.file(project.hasProperty("public_name") ? project.property("public_name") : "public_n.xml")
    if (publicNewXml.exists()) {
        publicNewXml.delete()
    }
    publicNewXml.createNewFile()
    def writer = publicNewXml.newPrintWriter()

    if (publicXml.exists()) {
        publicXml.eachLine { line ->
            String tmp = line.trim()
            println "public.xml line ${line}"
//            if (tmp.isEmpty()) {
//                return
//            }

            if ((tmp.startsWith("<!--") || tmp.endsWith("-->"))
                && tmp.contains("Declared at")) {
                // comment line
                return
            }
            println "write to new public.xml ${line}"
            writer.write(line)
            writer.write("\n")
        }
        writer.close()
    }
}

task JarSupport(type: Jar, dependsOn: ['compileReleaseJavaWithJavac']) {
    archiveName = "android_support_${ANDROID_SUPPORT_VERSION}.jar"
    destinationDir = file('build/libs')
    from project.configurations.compile.findAll {
        def path = it.getAbsolutePath()
        (path.contains("support") || path.contains("arch")) &&
                (path.endsWith(".jar") || path.endsWith(".aar"))
    }.collect {
        if (it.getName().endsWith('.jar')) {
            project.zipTree(it)
        } else if (it.getName().endsWith('.aar')) {

            def aarDir = project.file("${project.buildDir}/aar")
            if (!aarDir.exists()) {
                aarDir.mkdirs()
            }

            def aarPath = it.getPath()
            def hash = Math.abs(aarPath.hashCode())
            def jarName = it.getName().replace('.aar', '') + '-' + hash + '.jar'

            copy {
                from zipTree(aarPath)
                into aarDir
                include('**/*.jar')
                rename 'classes.jar', jarName
            }
            project.zipTree("${aarDir.absolutePath}/$jarName")
        }
    }
    include("android/support/**/*.class")
    include("android/arch/**/*.class")
}

task JarFresco(type: Jar, dependsOn: ['compileReleaseJavaWithJavac']) {
    archiveName = "fresco_${FRESCO_VERSION}.jar"
    destinationDir = file('build/libs')
    from project.configurations.compile.findAll {
        def path = it.getAbsolutePath()
        path.contains("fresco") &&
                (path.endsWith(".jar") || path.endsWith(".aar"))
    }.collect {
        if (it.getName().endsWith('.jar')) {
            project.zipTree(it)
        } else if (it.getName().endsWith('.aar')) {
            def aarDir = project.file("${project.buildDir}/aar")
            if (!aarDir.exists()) {
                aarDir.mkdirs()
            }

            def aarPath = it.getPath()
            def hash = Math.abs(aarPath.hashCode())
            def jarName = it.getName().replace('.aar', '') + '-' + hash + '.jar'

            copy {
                from zipTree(aarPath)
                into aarDir
                include('**/*.jar')
                rename 'classes.jar', jarName
            }
            project.zipTree("${aarDir.absolutePath}/$jarName")
        }
    }
    include("com/facebook/**/*.class")
}
